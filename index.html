<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUZI | KOBEDENSHI AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* 1. Page Background - Now a deeper blue-to-white gradient */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            
            /* Deeper Blue-White Gradient Background (blue-200 to white) */
            background: linear-gradient(180deg, #bfdbfe 0%, #ffffff 100%); 
        }

        /* The canvas is removed, but we keep the style block to explicitly hide it if a browser caches the ID */
        #weatherCanvas {
            display: none; 
        }

        /* 2. Main App Card - Opaque White, Clean Design */
        .glass-container {
            /* Opaque white card */
            background-color: white; 
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            /* Soft border */
            border: 1px solid #e0e7ff; /* blue-200 */ 
            /* Slightly stronger shadow for definition */
            box-shadow: 0 15px 45px 0 rgba(0, 0, 0, 0.1); 
            position: relative; 
            z-index: 10;
        }

        /* 3. Header - Opaque White */
        .header-glass {
            background-color: white; 
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            /* Clean separator */
            border-bottom: 1px solid #e0e7ff;
        }

        /* 3. Input Area - Opaque Off-White */
        #chat-form {
            background-color: #f9fafb; /* light gray/off-white for distinction */
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            /* Clean separator */
            border-top: 1px solid #e0e7ff;
        }
        
        /* 4. Chat Bubbles - Adjust for light background */
        .bot-bubble {
            /* Opaque light gray for bot */
            background-color: #f1f5f9; /* slate-100 */ 
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border: 1px solid #e0e7ff;
            color: #1f2937; /* Dark text for contrast */
        }

        .user-bubble {
            /* Opaque Sky Blue for user */
            background-color: #0ea5e9; /* sky-500 */
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border: 1px solid #0369a1; /* Darker blue border */
            color: white; 
        }

        /* Custom scrollbar styling for a cleaner look */
        #chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        #chat-messages::-webkit-scrollbar-thumb {
            background-color: #0ea5e9; /* sky-600 */
            border-radius: 4px;
        }
        #chat-messages::-webkit-scrollbar-track {
            background-color: rgba(0, 0, 0, 0.05); /* Very light track */
        }

        /* Ensure smooth animation for the loading indicator */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        .loading-dot {
            animation: pulse 1.5s infinite;
        }
        .loading-dot:nth-child(2) {
            animation-delay: 0.3s;
        }
        .loading-dot:nth-child(3) {
            animation-delay: 0.6s;
        }
    </style>
</head>
<body class="h-full flex items-center justify-center p-0">
    <div id="app" class="glass-container w-full max-w-full flex flex-col h-screen rounded-xl overflow-hidden md:h-[90vh] md:w-[90vw] lg:w-[70vw] xl:w-[50vw] relative z-10">
        
        <header class="p-4 header-glass flex items-center justify-between shadow-lg">
            <div class="flex items-center space-x-4">
                
                <div class="w-12 h-12 rounded-full bg-sky-500 flex items-center justify-center shadow-lg flex-shrink-0 overflow-hidden border-2 border-white">
                    <img 
                        src="suzi-profile.png" 
                        alt="SUZI Profile Photo" 
                        class="w-full h-full object-cover"
                        onerror="this.onerror=null; this.src='https://placehold.co/48x48/0ea5e9/ffffff?text=Logo';" 
                    />
                </div>
                
                <div class="flex flex-col space-y-1">
                    <h1 class="text-xl font-bold text-gray-900">SUZI (KOBEDENSHI AI)</h1>
                    <p class="text-xs opacity-90 text-gray-700">Created by: ÊÉÖÂ†±Âá¶ÁêÜÂ≠¶Áßë„ÅÆÂ≠¶Áîü KYAW KHAING TUN</p>
                </div>
            </div>
            
            <span id="status-badge" class="text-sm bg-gray-400 py-1 px-3 rounded-full font-medium text-white shadow-md">Connecting...</span>
        </header>

        <div id="chat-messages" class="flex-grow overflow-y-auto p-4 space-y-4">
            <div class="flex justify-start">
                <div class="flex flex-col">
                    <div class="bot-bubble text-gray-800 p-3 rounded-xl rounded-tl-none shadow-md max-w-lg md:max-w-xl">
                        <p>Hello! I am SUZI, the testing AI assistant for KOBEDENSHI College. I can speak both English and Japanese, and I can access real-time cloud data. How can I help you today?
                        <br><br>„Åì„Çì„Å´„Å°„ÅØÔºÅÁßÅ„ÅØ SUZIÔºà„Çπ„Éº„Ç∏„ÉºÔºâ „Åß„Åô„ÄÇ
                        Á•ûÊà∏ÈõªÂ≠êÂ∞ÇÈñÄÂ≠¶Ê†°ÔºàKOBEDENSHIÔºâ„ÅÆ„ÉÜ„Çπ„ÉÜ„Ç£„É≥„Ç∞AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ
                        <br><br>Ëã±Ë™û„Å®Êó•Êú¨Ë™û„ÅÆ2„ÅãÂõΩË™û„ÅßË©±„Åô„Åì„Å®„Åå„Åß„Åç„ÄÅ„ÇØ„É©„Ç¶„Éâ„Åã„Çâ„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†„Éá„Éº„Çø„ÇÇË™≠„ÅøÂèñ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
                        <br><br>Êú¨Êó•„ÅØ„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å´„ÅäÊâã‰ºù„ÅÑ„Åó„Åæ„Åó„Çá„ÅÜ„ÅãÔºü ‚ú®</p>
                    </div>
                </div>
            </div>
        </div>

        <form id="chat-form" class="p-4"> 
            <div class="flex flex-col space-y-2">
                <div class="flex items-center space-x-3">
                    
                    <input type="text" id="user-input" placeholder="Type your question (Try 'what time is it', or 'what do you see')"
                           class="flex-grow p-3 border border-sky-300 bg-white rounded-xl focus:ring-2 focus:ring-sky-600 focus:border-sky-600 transition duration-150 shadow-inner text-gray-900 placeholder-gray-500"
                           required autocomplete="off">

                    <button type="submit" id="send-btn" 
                            class="p-3 text-white bg-sky-500 rounded-lg hover:bg-sky-600 transition duration-150 flex items-center justify-center disabled:opacity-50 shadow-md hover:shadow-lg"
                            title="Send Message">
                        <i data-lucide="send" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </form>
    </div>

    <script>
        // Set up Lucide icons
        window.onload = () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            // Ensure the main logic runs after icons are rendered
            initChatbot();
        };

        let collegeData = null;

        // --- Helper: describeLiveViewFromCloud() has been REMOVED as its functionality is now handled by the AI for cleaner, more flexible output. ---

        const CLOUD_DATA_URL = "https://cloud-2-9ndj.onrender.com";
        

        function initChatbot() {
            // --- CONSTANTS ---
            // 1. Updated SYSTEM_PROMPT
            const SYSTEM_PROMPT = `
You are SUZI, the friendly and highly knowledgeable AI Assistant for KOBEDENSHI College.(testing)

This specific application, SUZI, was created by Information Technology Department student
KYAW KHAING TUN („Ç≠„Éß„Éº„Ç´„Ç§„Éº„É≥„Éà„É≥). When asked who created you, you MUST ONLY mention
the student creator, KYAW KHAING TUN. Do NOT mention Google or the foundational model developer.

You receive real-time JSON data from the KOBEDENSHI cloud (live_data). This JSON represents
what the camera can currently see (for example: number of people, where they are,
time, place, and other detections).using that data guess what are they doing

IMPORTANT RULES ABOUT ‚ÄúWHAT YOU SEE‚Äù:
- If the user asks things like:
  - "What do you see?"
  - "What can you see now?"
  - "What is happening now?"
  - "‰ªä‰Ωï„ÅåË¶ã„Åà„ÇãÔºü"
  - "‰ªä‰Ωï„ÇíË¶ã„Å¶„ÅÑ„Åæ„Åô„Åã?"
  then you MUST answer using ONLY the latest live_data from the cloud, imagination.
- If live_data is missing or cannot be understood, you must clearly say that you cannot
  see anything right now or that the data format is unknown.

General behavior:
- Your primary role is to provide information, guidance, and assistance to students, faculty,
  and prospective applicants related to the college.
- You can use the cloud JSON data (announcements, events, etc.) when it is helpful.
- You are proficient in both English and Japanese. Reply in the same language as the user,
  or switch language immediately when the user requests it.
- Maintain a helpful and professional tone.
- Image analysis is not supported in this version.
`;
            const INITIAL_BOT_TEXT = "Hello! I am SUZI, the testing AI assistant for KOBEDENSHI College. I can speak both English and Japanese, and I can access real-time cloud data. How can I help you today?";
            
            // --- API Setup (MODIFIED SECTION A: REMOVED KEY/URL, ADDED ENDPOINT) ---
            // const API_KEY = ""; // REMOVED: Key is now secured on the server
            // const TEXT_MODEL_URL = "..."; // REMOVED: Use the proxy endpoint
            const CHAT_ENDPOINT = "/api/chat"; // ADDED: New proxy endpoint
            const MAX_RETRIES = 5;
            
            // Conversation history (stores role and parts for API calls, lost on reload)
            let chatHistory = [];
            
            // Initialize chatHistory with the first bot message
            chatHistory.push({
                role: "model", 
                parts: [{ text: INITIAL_BOT_TEXT }] 
            });

            // --- DOM Elements ---
            const form = document.getElementById('chat-form');
            const input = document.getElementById('user-input');
            const messagesContainer = document.getElementById('chat-messages');
            const statusBadge = document.getElementById('status-badge');
            const sendBtn = document.getElementById('send-btn'); 


            // --- Utility Functions ---

            // Function to add a message bubble to the chat window
            function addMessage(text, role, originalBotText = null) { 
                const messageWrapper = document.createElement('div');
                
                // Content wrapper for message and button
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'flex flex-col';

                const messageContent = document.createElement('div');

                if (role === 'user') {
                    messageWrapper.className = 'flex justify-end';
                    // Updated to use the 'user-bubble' class
                    messageContent.className = 'user-bubble p-3 rounded-xl rounded-br-none shadow-md max-w-lg md:max-w-xl text-white'; 
                    messageContent.innerHTML = text.replace(/\n/g, '<br>');

                } else { // bot or system
                    messageWrapper.className = 'flex justify-start';
                    
                    // Updated to use the 'bot-bubble' class
                    messageContent.className = 'bot-bubble text-gray-800 p-3 rounded-xl rounded-tl-none shadow-md max-w-lg md:max-w-xl';
                    messageContent.innerHTML = text.replace(/\n/g, '<br>');
                }
                
                contentWrapper.prepend(messageContent); // Place message content first
                messageWrapper.appendChild(contentWrapper);
                messagesContainer.appendChild(messageWrapper);
                
                // Auto-scroll to the bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                // Re-create lucide icons for the new button
                if (typeof lucide !== 'undefined') lucide.createIcons();
                
                return messageContent; // Return the content element for updates (like loading)
            }


            // Function to add a dynamic loading indicator (three dots)
            function addLoadingIndicator(isSummary = false) {
                const loadingWrapper = document.createElement('div');
                loadingWrapper.className = 'flex justify-start';
                loadingWrapper.id = 'loading-indicator';
                
                const mtClass = isSummary ? 'mt-1' : '';
                
                const loadingContent = document.createElement('div');
                // Loading indicator uses the bot-bubble style
                loadingContent.className = `bot-bubble p-3 rounded-xl rounded-tl-none shadow-sm max-w-xs md:max-w-md flex space-x-1 ${mtClass}`;

                for (let i = 0; i < 3; i++) {
                    const dot = document.createElement('span');
                    dot.className = 'loading-dot w-2 h-2 bg-sky-600 rounded-full';
                    dot.style.animationDelay = `${i * 0.3}s`; // Stagger animation
                    loadingContent.appendChild(dot);
                }

                loadingWrapper.appendChild(loadingContent);
                messagesContainer.appendChild(loadingWrapper);
                
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                return loadingWrapper;
            }

            // Function to remove the loading indicator
            function removeLoadingIndicator(indicatorElement) {
                if (indicatorElement) {
                    indicatorElement.remove();
                }
            }

            // Try to find the newest live-data block in the cloud JSON
            function extractLatestLiveBlock(collegeData) {
                if (!collegeData) return null;

                // 1) Old style: { ok: true, data: { history: [...] } }
                if (collegeData.ok && collegeData.data && Array.isArray(collegeData.data.history)) {
                    return collegeData.data;
                }

                // 2) Old style: { live_data: { history: [...] } }
                if (collegeData.live_data && Array.isArray(collegeData.live_data.history)) {
                    return collegeData.live_data;
                }

                // 3) New multi-location style: keys like "live_main_tower_3f"
                for (const [key, value] of Object.entries(collegeData)) {
                    if (key.startsWith("live_") && value && Array.isArray(value.history)) {
                        return value;     // pick the first live_* block
                    }
                }

                return null;
            }

            // Build a snapshot of the latest frame for ALL live_* locations
            function buildLiveSnapshot(collegeData) {
                if (!collegeData) return null;

                const snapshot = {};

                for (const [key, value] of Object.entries(collegeData)) {
                    if (!key.startsWith("live_") || !value) continue;

                    let latestFrame = null;

                    // Pattern A: { history: [...] }
                    if (Array.isArray(value.history) && value.history.length > 0) {
                        latestFrame = value.history[value.history.length - 1];
                    }
                    // Pattern B: { data: { history: [...] } }
                    else if (value.data && Array.isArray(value.data.history) && value.data.history.length > 0) {
                        latestFrame = value.data.history[value.data.history.length - 1];
                    }
                    // Pattern C: { objects: [...] } (single frame style)
                    else if (Array.isArray(value.objects)) {
                        latestFrame = value;
                    }

                    if (latestFrame) {
                        snapshot[key] = latestFrame;
                    }
                }

                return snapshot;
            }


            // Exponential backoff retry logic for fetch calls
            async function fetchWithRetry(url, options, retries = 0) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // Special handling for your new proxy endpoint
                        if (url.startsWith(CHAT_ENDPOINT) && response.status === 500) {
                             const errorBody = await response.json();
                             throw new Error(`Proxy Server Error: ${errorBody.error || 'Unknown error'}`);
                        }

                        if (response.status === 429 && retries < MAX_RETRIES) {
                            const delay = Math.pow(2, retries) * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return fetchWithRetry(url, options, retries + 1);
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (retries < MAX_RETRIES) {
                        const delay = Math.pow(2, retries) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return fetchWithRetry(url, options, retries + 1);
                    }
                    throw error;
                }
            }
            
            // --- New Helper for Silent Cloud Data Refresh (STEP 1) ---
            async function fetchLatestCloudDataSilent() {
                const DATA_ENDPOINT = `${CLOUD_DATA_URL}/all_json`;

                try {
                    const response = await fetchWithRetry(DATA_ENDPOINT, { method: 'GET' });
                    const data = await response.json();
                    collegeData = data;
                    console.log("Silent cloud refresh OK:", collegeData);
                    return collegeData;
                } catch (error) {
                    console.error("Silent cloud refresh FAILED:", error);
                    return null;
                }
            }
            
            // --- Data Fetching Logic (Updated to control the Status Badge) ---
            async function fetchCloudData() {
                const DATA_ENDPOINT = `${CLOUD_DATA_URL}/all_json`;

                // Set initial status to connecting
                statusBadge.textContent = "Connecting...";
                statusBadge.className = "text-sm bg-gray-400 py-1 px-3 rounded-full font-medium text-white shadow-md";

                try {
                    // NOTE: This fetch still goes to the cloudflare endpoint, not the new proxy
                    const response = await fetchWithRetry(DATA_ENDPOINT, { method: 'GET' });
                    const data = await response.json();
                    collegeData = data;
                    
                    console.log("Cloud data fetched successfully:", collegeData);
                    
                    // Update UI for success (Online)
                    statusBadge.textContent = "Online";
                    statusBadge.className = "text-sm bg-green-500 py-1 px-3 rounded-full font-medium text-white shadow-md";

                    const infoMessage = `<i data-lucide="cloud-check" class="w-4 h-4 inline mr-1 text-green-600"></i> SUZI has successfully loaded real-time data from the KOBEDENSHI Cloud System. This data will be used for current announcements. <br>SUZI„ÅØÁ•ûÊà∏ÈõªÂ≠ê„ÅÆ„ÇØ„É©„Ç¶„Éâ„Ç∑„Çπ„ÉÜ„É†„Åã„Çâ„É™„Ç¢„É´„Çø„Ç§„É†„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü„ÄÇ„Åì„ÅÆ„Éá„Éº„Çø„ÅØÊúÄÊñ∞„ÅÆ„ÅäÁü•„Çâ„Åõ„Å´Âà©Áî®„Åï„Çå„Åæ„Åô„ÄÇ`;
                    addMessage(infoMessage, 'bot');
                    
                } catch (error) {
                    console.error("Failed to fetch cloud data:", error);
                    
                    // Update UI for failure (Offline)
                    statusBadge.textContent = "Offline";
                    statusBadge.className = "text-sm bg-red-500 py-1 px-3 rounded-full font-medium text-white shadow-md";

                    const errorMessage = `<i data-lucide="cloud-off" class="w-4 h-4 inline mr-1 text-red-600"></i> Alert: SUZI failed to load real-time data from the KOBEDENSHI cloud system. Answers may not reflect the absolute latest announcements.`;
                    addMessage(errorMessage, 'bot');
                }
            }
            
            // Start fetching data immediately
            fetchCloudData();
            
            // --- Core Logic: Handle Form Submission (MODIFIED) ---
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const userQuery = input.value.trim();
                
                // If query is empty, stop.
                if (!userQuery) return; 

                // Lock the UI immediately
                input.disabled = true;
                sendBtn.disabled = true; 

                const normalizedQuery = userQuery.toLowerCase();
                let commandFound = false;

                // --- Time question handling (local JS, no Gemini) ---
                const timePatterns = [
                    "what time is it",
                    "what time it is",
                    "‰ªä‰ΩïÊôÇ",
                    "‰ªä‰ΩïÊôÇ„Åß„Åô„Åã",
                    "„ÅÑ„Åæ„Å™„Çì„Åò",
                    "„ÅÑ„Åæ„Å™„Çì„Åò„Åß„Åô„Åã"
                ];
                
                const matchedTimeQuestion = timePatterns.some(p =>
                    normalizedQuery.includes(p.toLowerCase())
                );
                
                if (matchedTimeQuestion) {
                    addMessage(userQuery, 'user');

                    const now = new Date();
                    // Force Asia/Tokyo style display
                    const optionsDate = { year: "numeric", month: "long", day: "numeric", timeZone: "Asia/Tokyo" };
                    const optionsTime = { hour: "numeric", minute: "2-digit", hour12: true, timeZone: "Asia/Tokyo" };
                    const optionsTimeJa = { hour: "numeric", minute: "2-digit", timeZone: "Asia/Tokyo" };

                    const dateStr = now.toLocaleDateString("en-US", optionsDate);
                    const timeStr = now.toLocaleTimeString("en-US", optionsTime);
                    const timeStrJa = now.toLocaleTimeString("ja-JP", optionsTimeJa);

                    const reply = `
The current local time at KOBEDENSHI College (Kobe, Japan) is **${timeStr}** on **${dateStr}** (Japan Standard Time, JST).

ÁèæÂú®„ÅÆÁ•ûÊà∏ÈõªÂ≠êÂ∞ÇÈñÄÂ≠¶Ê†°ÔºàÊó•Êú¨„ÉªÁ•ûÊà∏Ôºâ„ÅÆÊôÇÂàª„ÅØ **${timeStrJa}ÔºàÊó•Êú¨ÊôÇÈñìÔºâ** „Åß„Åô„ÄÇ
                    `.trim();

                    addMessage(reply, 'bot');

                    // Unlock UI and return without calling Gemini
                    input.value = '';
                    input.disabled = false;
                    sendBtn.disabled = false;
                    input.focus();
                    return;
                }

                // 2. Check for "what do you see" / "‰ªä‰Ωï„ÅåË¶ã„Åà„Çã" questions (AI-BASED VISION MODE)
                const seeNowPatterns = [
                    // English ‚Äì simple forms
                    "what do you see",
                    "what you see",
                    "what can you see",
                    "what are you seeing",
                    "what do you see now",
                    "what you see now",
                    "what can you see now",

                    // English ‚Äì user-like phrasings
                    "tell me what you see",
                    "tell me exactly what you see",
                    "tell me what do you see",
                    "tell me exactly what do you see",

                    // Japanese ‚Äì more variations
                    "‰ªä‰Ωï„ÅåË¶ã„Åà„Çã",
                    "‰ªä‰Ωï„ÅåË¶ã„Åà„Åæ„Åô„Åã",
                    "‰ªä‰Ωï„ÇíË¶ã„Å¶„ÅÑ„Çã",
                    "‰ªä‰Ωï„ÇíË¶ã„Å¶„ÅÑ„Åæ„Åô„Åã",
                    "‰ªä‰Ωï„ÅåÊò†„Å£„Å¶„ÅÑ„Çã",
                    "‰ªä‰Ωï„ÅåÊò†„Å£„Å¶„ÅÑ„Åæ„Åô„Åã",
                    "what's happening right now"
                ];

                const matchedSeeQuestion = seeNowPatterns.some(p =>
                    normalizedQuery.includes(p.toLowerCase())
                );

                if (matchedSeeQuestion) {
                    addMessage(userQuery, 'user');
                    const loadingIndicator = addLoadingIndicator();

                    // üîπ Always refresh from cloud for this question (STEP 2)
                    await fetchLatestCloudDataSilent(); 

                    // 1Ô∏è‚É£ Build snapshot for ALL live_* locations
                    const snapshot = buildLiveSnapshot(collegeData);

                    if (!snapshot || Object.keys(snapshot).length === 0) {
                        removeLoadingIndicator(loadingIndicator);
                        addMessage(
                            "I cannot see anything right now because valid live camera data was not found.\n\nÁèæÂú®„ÄÅÊúâÂäπ„Å™„É©„Ç§„Éñ„Ç´„É°„É©„ÅÆ„Éá„Éº„Çø„ÅåÂèñÂæó„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ„ÄÅ‰Ωï„ÇÇÁ¢∫Ë™ç„Åß„Åç„Åæ„Åõ„Çì„ÄÇ",
                            "bot"
                        );
                        input.value = '';
                        input.disabled = false;
                        sendBtn.disabled = false;
                        input.focus();
                        return;
                    }

                    // 2Ô∏è‚É£ Send ALL live_* JSON to the AI
                    const visionPrompt = `
You are SUZI, the testing AI assistant of KOBEDENSHI College.

The user asked: "${userQuery}"

You are given LIVE CAMERA JSON with detection results from multiple locations.
Each key such as "live_Êú¨È§®", "live_hall", "live_„Ç®„É≥„Éà„É©„É≥„Çπ" indicates the camera location.

You MUST:
- Use ONLY this JSON.
- If the user mentions a specific location (e.g. Êú¨È§®, „Éõ„Éº„É´, „Ç®„É≥„Éà„É©„É≥„Çπ),
  focus your answer on that place.
- If the location is not specified, you should summarize what is happening
  across all locations.
- Using that data, guess what people might be doing (for example: walking,
  waiting, talking, entering the building), but keep your guesses realistic.
- If something is not in the JSON, do NOT mention it.

LIVE CAMERA JSON:${JSON.stringify(snapshot, null, 2)}
`.trim();

                    // Temporary push for this specific question
                    const tempHistoryEntry = {
                        role: "user",
                        parts: [{ text: visionPrompt }]
                    };
                    chatHistory.push(tempHistoryEntry);

                    const payload = {
                        contents: chatHistory,
                        tools: [{ "google_search": {} }],
                        systemInstruction: {
                            parts: [{ text: SYSTEM_PROMPT }]
                        }
                    };

                    try {
                        const response = await fetchWithRetry(CHAT_ENDPOINT, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });

                        const result = await response.json();
                        removeLoadingIndicator(loadingIndicator);

                        if (result?.candidates?.[0]?.content?.parts?.[0]?.text) {
                            const aiReply = result.candidates[0].content.parts[0].text;

                            // Add AI reply to history permanently
                            chatHistory.push({
                                role: "model",
                                parts: [{ text: aiReply }]
                            });

                            addMessage(aiReply, "bot");
                        } else {
                            addMessage("AI failed to describe the camera view.", "bot");
                            // Remove the temporary user prompt if AI failed
                            chatHistory.pop();
                        }
                    } catch (err) {
                        removeLoadingIndicator(loadingIndicator);
                        addMessage("AI vision error: " + err.message, "bot");
                        // Remove the temporary user prompt if fetch failed
                        chatHistory.pop();
                    }

                    input.value = '';
                    input.disabled = false;
                    sendBtn.disabled = false;
                    input.focus();
                    return;
                }

                // --- If none of the above were found, proceed to AI Text flow ---
                
                // 3. Display user message
                addMessage(userQuery, 'user');
                
                const loadingIndicator = addLoadingIndicator();

                // 4. Standard Text Flow
                
                // --- Construct Payload ---
                const parts = [];
                
                // Add Text part
                const textContent = userQuery;
                parts.push({ text: textContent });


                // 5. Prepare Context with Cloud Data
                let contextPrompt = "";
                if (collegeData) {
                    const dataString = JSON.stringify(collegeData);
                    const safeDataString = dataString.substring(0, 1000); 
                    // Add the context to the part that is sent to the model (in the history)
                    contextPrompt = `[KOBEDENSHI College Real-Time Cloud Data: ${safeDataString}] \n\n `;
                }
                
                const fullUserMessage = contextPrompt + "User Query: " + textContent;
                
                // 6. Add full user message (with context) to history
                chatHistory.push({
                    role: "user",
                    parts: [{ text: fullUserMessage }] 
                });

                // 7. Construct API Payload for Text Understanding
                const payload = {
                    contents: chatHistory, 
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: SYSTEM_PROMPT }]
                    },
                };
                
                // Fix: Overwrite parts of the last history entry with the user-only part for the API call 
                // This is a common pattern when inserting a context prompt into the history for the model to see.
                const lastHistoryItemIndex = chatHistory.length - 1;
                payload.contents[lastHistoryItemIndex].parts = [{ text: fullUserMessage }]; 
                
                // Now, execute the call to your secure proxy endpoint (MODIFIED SECTION B)
                try {
                    const response = await fetchWithRetry(CHAT_ENDPOINT, { 
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        
                        const aiText = result.candidates[0].content.parts[0].text;
                        
                        // 8. Add AI message to history
                        chatHistory.push({
                            role: "model",
                            parts: [{ text: aiText }]
                        });

                        // 9. Display response.
                        removeLoadingIndicator(loadingIndicator);
                        addMessage(aiText, 'bot', aiText); 
                        
                    } else {
                        // 10. Handle error
                        removeLoadingIndicator(loadingIndicator);
                        addMessage("AI„Åã„Çâ„ÅÆÂøúÁ≠î„ÅåÁ©∫„Åæ„Åü„ÅØ‰∏çÊ≠£„Å™ÂΩ¢Âºè„Åß„Åó„Åü„ÄÇ", 'bot'); 
                        console.error("AI Response Error:", result);
                        // Remove the user's last message from history if the AI failed to reply
                        chatHistory.pop(); 
                    }

                } catch (error) {
                    // 11. Handle error display
                    removeLoadingIndicator(loadingIndicator);
                    addMessage(`„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}. ÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`, 'bot');
                    console.error("API Call Failed:", error);
                    // Remove the user's last message from history if the API call failed
                    chatHistory.pop(); 
                }
                
                // 12. Unlock the UI and focus input
                input.value = '';
                input.disabled = false;
                sendBtn.disabled = false; 
                input.focus();
            });
        }
    </script>
</body>
</html>
